% !Mode:: "TeX:UTF-8"

\chapter{分层的动态温度管理方法}\label{sec:new_method}

在这一章，针对高性能众核微处理器，提出了新的分层动态温度管理方法。新方法是基于模型预测控制而且采用了任务迁移和 DVFS。
众核处理器上执行结合任务迁移的 MPC 是一个挑战，因为但处理器处理器核数非常的大，
用复杂度为$O(n^{3})$的匈牙利算法计算任务迁移的决策需要花费大量的时间，这个时间可以看成是二部图匹配的时间。
为了扩展到具有大量处理器核的众核处理器，新的方法将处理器分成块，在两个层次上进行任务迁移决策：块内（低层）和块间（高层）。
首先在低层，也就是块内执行当前功耗和期望功耗组成的二部图匹配。在低层内没有匹配上的功耗元素，收集起来形成高层，也就是块间。
在高层，用改进的迭代最小割算法~\cite{Fidducia:DAC'82}  将高层分成“优化”块，在每个“优化”块执行二部图匹配。
高层最后没有匹配的功耗元素用 DVFS 来处理，以保证绝对的温度安全。
分层算法通过减小二部图匹配规模来降低计算开销，而且匹配是并行执行的，大大减少了计算时间，所以该算法可以扩展到众核系统。

\section{低层块内任务迁移}\label{sec:parts}

首先，我们将众核处理器分割成块。作为第一步，我们可以简单根据核的位置分割处理器。
就是在空间上直接划分处理器成块。
这一步分割不需要任何开销。我们通常将方形的块叫普通块，在边缘可能会出现矩形或者小的方形块，把这些称作边缘块。

块内匹配就是执行 \ref{sec:dtm_mpc} 节中说明了二部图匹配的过程，这个叫做低层匹配。对每一个块，指定一个块内的核执行匹配的计算。
从整个芯片来看，低层匹配的计算是并行执行的。所以底层匹配引入的延迟时间只是一个普通块低层匹配的时间（注意，边缘块比常规快要小，也就是说它们的计算时间也并不计算在内）。

可以调整块内的核数以实现整个算法更小的延迟时间：如果核数很大，低层的功耗匹配将会占用更多的时间，
但是可以发现更多的匹配对，将会剩余更少的未匹配功耗到高层，这样高层匹配处理时间就会减少。

图~\ref{fig:cpu_partition} (a)是一个简单的低层划分的例子。这是一个 100 核微处理器，被划分为四个 16 核普通块（标记为A、B、D、E），五个核数 4 到 8 核的边缘块（标记为C、F、G、H、I）。
低层的功耗匹配将在每一个块内执行。图~\ref{fig:bi2} 展示的正是图~\ref{fig:cpu_partition} (a)中块I内的二部图匹配。

\begin{pics}[h]{100核微处理器的垂直视图 （作为分层算法的一个例子）}{fig:cpu_partition}
  \centering
    \addsubpic{微处理器分割成块准备进行低层二部图匹配}{width=0.4\columnwidth}{fig/part1}
  \addsubpic{低层二部图匹配之后留下的未匹配核（红色）}{width=0.4\columnwidth}{fig/partmod}

\end{pics}

显然，只执行低层的块内功耗匹配不足以找到所有的匹配对。
例如，在图~\ref{fig:cpu_partition} (a) 的块 I 中， 图~\ref{fig:bi2} (b) 已经表示出
功耗 $p_1$ 和 $\bar{p}_4$ 不能匹配。
对低层匹配阶段块内未匹配功耗直接执行 DVFS 并不是好办法，因为一个块内的未匹配功耗可能在其他块找到很好匹配的期望功耗。
这样就可以避免太多不必要的 DVFS 行为，将性能损失最小化。
所以，我们可以收集所有块内低层匹配时未匹配的功耗，形成高层。图~\ref{fig:cpu_partition} (b) 中表示出第一次底层匹配后未匹配的功耗。

\section{高层块间任务迁移}\label{sec:fm}

在上一节中，我们已经将所有处理器核划分成块，完成了块内低层二部图匹配。将所有低层块中的未匹配上的功耗收集起来，为高层匹配做准备。

我们希望在高层匹配中找到所有的匹配功耗对，只在那些最后匹配不上的功耗上执行 DVFS。
似乎我们可以像划分低层块一样，继续按照核的位置来将高层核划分成更大的块。然后我们在新的块内进行二部图匹配，用未匹配上的再形成更大的块。
块的大小在迭代中变大，知道整个芯片最后变成一个块。然而，实验表明，在高层匹配中，只有很少比例（低于 $25\%$ ）的功耗可以被最终匹配上。
相比之下，在底层功耗匹配中比例较大（高于 $60\%$ ）。
这样小的比例将会使块大小在迭代中增长非常缓慢，甚至有可能块的大小永远不会增长到整个芯片那么大，因为有可能有太多功耗不能最终匹配。
所以在块的大小增加到整个芯片那么大之前，块内收集的未匹配功耗就可能太多而不能处理，因为这需要巨大的计算开销。

为了使高层任务迁移决策更加有效率，我们用另外一种方法将高层功耗划分成块，即最小割算法。
首先我们用高层功耗生成一个图（后面将会详细介绍）。
然后，我们用最小割算法将图分成两组，每一组是一个新的块（高层的块中的核已经不像低层块一样空间上相邻了）。
如果这个新块的大小太大（对二部图匹配算法而言），对这个块在进行一次最小割算法，将其大小减半。
在最小割之后，每一个新块内执行二部图匹配。
最小割的一个重要特性就是不同的新块之间的元素关系非常弱。新块内的元素关系非常强。
这意味着每个新块内部匹配率最大。
如果有功耗元素在新块内二部图匹配仍未匹配上，那它也很难与其他新块内的元素匹配上。
所以，高层未匹配功耗再收集起来做更高层次的匹配是没有必要的了。

通常情况下，精确的最小割算法开销太大不能实时执行。幸运的是，我们这里并不需要最优的割，我们采用迭代近似算法改进形式，该算法曾被用在网络分割上 \cite{Fidducia:DAC'82} 。
首先我们用所有高层未匹配功耗建立一个新图 $\mathcal{G}_p = (V_p, E_p)$，
其中 $V_p=\{p_1, \bar{p}_1, p_2, \bar{p}_2, \cdots, p_m, \bar{p}_m\}$， 
$E_p$ 包含 $V_p$ 中所有元素的带权重的边。
权重这样定义：对所有的 $i$ 和 $j$ ，  $w(p_i, \bar{p}_j) = 1/|p_i-\bar{p}_j|$，
$w(p_i, p_j) = 0$， $w(\bar{p}_i, \bar{p}_j) = 0$  。
图~\ref{fig:partitioning} (a) 展示了 $\mathcal{G}_p$ 的一个例子。 
我们这里需要解决的是图 $\mathcal{G}_p$ 上的最小割问题。 

\begin{pics}{分层算法在100核微处理器上的高层处理过程示例}{fig:partitioning}
  \centering
    \addsubpic{图 $\mathcal{G}_p$ （为简化并未表示出边和权重）}
  {width=0.4\columnwidth}{fig/partition}
  \addsubpic{ $\mathcal{G}_p$上的初始割（改进迭代最小割算法的第一步）}
  {width=0.4\columnwidth}{fig/partition3}
  \addsubpic{$\mathcal{G}_p$上的最小割，每个高层块中的二部图匹配}
  {width=0.4\columnwidth}{fig/match_aft_partition}
  \addsubpic{对未匹配的功耗用DVFS做最后调整}
  {width=0.4\columnwidth}{fig/DVFS}
\end{pics}

作为一个迭代算法，第一步是做一个初始割，将 $V_p$ 分成两个子集 $V_{p1}$ 和 $V_{p2}$。
定义割的权值就是割集的权重的和。图~\ref{fig:partitioning} (b)给出了一个例子，
其中初始割生成了两个子集 $V_{p1}=\{P_a, P_b, P_c, \bar{P}_a,
  \bar{P}_b, \bar{P}_c\}$ 和 $V_{p2}=\{P_d, P_e, \bar{P}_d,
  \bar{P}_e\}$。
  
  然后，为了将正确的元素从一个子集移到另一个子集进行迭代，我们需要测定一个移动操作导致的割的权值变化。
  对每一个元素 $v$ ， 我们首先将元素 $v$ 和相同子集中元素的边集定义为 $I(v)$ ，类似地，将元素 $v$ 和不同子集中的元素的边集定义为 $E(v)$ 。
  下面将图~\ref{fig:partitioning} (b)中的元素 $P_a$ 做一个例子。
  \begin{equation}
  \begin{split}
  I(P_a) &= \{(P_a,\bar{P}_a), (P_a, \bar{P}_b), (P_a, \bar{P}_c)\}\\
  E(P_a) &= \{(P_a, \bar{P}_d), (P_a, \bar{P}_e, \}
  \end{split}
  \end{equation}
 % $I(P_a) = \{(P_a, \bar{P}_a), (P_a, \bar{P}_b), (P_a, \bar{P}_c)\}$， $E(P_a) =
 % \{(P_a, \bar{P}_d), (P_a, \bar{P}_e, \}$。
  注意这里我们将权重为 $0$ 的边忽略掉，例如 $(P_a, P_b)$ 等。
  下面是增益函数 $f(v)$。
  \begin{equation}
  f(v) = \sum_{n_i \in E(v)}{w(n_i )} - \sum_{n_j \in I(v)}{w(n_j )}
  \end{equation}
  $f(v)$ 测定的是如果 $v$ 移动到另一个子集，割的权值产生的减少量。
  在这个例子中 $f(P_a)$ 是这样计算的， $f(P_a) =
  (1/|P_a-\bar{P}_d|+1/|P_a-\bar{P}_e|)-(1/|P_a-\bar{P}_a|+1/|P_a-\bar{P}_b|+1/|P_a-\bar{P}_c|)=-1.40$。
  $f(P_a)$ 是负值表示移动 $f(P_a)$ 到另一个子集的操作会增加割的权值，这就表示 $f(P_a)$ 不应该被移动。
  类似地，其他元素的增益也都被计算了， $f(P_b)=-1.39$， $f(P_c) = 0.92$， $f(P_d) = -0.19$，
  $f(P_e)=0.62$， $f(\bar{P}_a) = -0.39$， $f(\bar{P}_b)=-1.33$，
  $f(\bar{P}_c)=-1.02$， $f(\bar{P}_d) = 0.46$， $f(\bar{P}_e) = 0.84$。
  对第 $i$ 次迭代，最合适的元素记作 $v_i$ 。  $v_i$ 移动过去之后，将被锁定在那个子集中，不能再移动出来。
  它相邻的元素的增益都要更新。在这个例子中，最合适的元素是 $P_c$ ， $P_c$ 有最大的增益 $0.92$ ，
  它将被移动到下面的子集然后锁定。
  在这个简单的例子中，我们可以很容易从图中验证，将 $P_c$ 从上面的子集移动到下面的子集，增强了功耗匹配质量：
$P_c$ 在下面子集中的 $\bar{P}_d$ 和 $\bar{P}_e$ 有一个更好的匹配候选，比上面子集的任何一个功耗元素都要好。
然而这里有一个问题，在这个例子中如果我们直接执行这个移动操作，每次迭代中都移动最合适的元素可能会导致一个极端不平衡的结果：
一个自己含有很多元素（功耗），另一个子集几乎没有元素。
对我们的方法这个会引起问题，因为如果最小割之后，其中一个块仍然很大，那这个块执行二部图匹配会产生很大的延迟。
所以我们在迭代最小割算法中引入一个平衡阈值：
如果将合适的元素从 A 移动到 B 会超出阈值，那它将不被移动。相反的从 B 中选择最合适的元素移动到 A 并且锁定。
所有元素都被锁定之后，生成了一个序列 ， $\mathcal{F} = \{f(v_1), f(v_2), \cdots, f(v_{2m})\}$ 。
在这个阶段，我们已经移动了所有的元素到对应的另一个子集，这看起来似乎很奇怪，但这不是没有意义的。
实际的情况是，所有的移动操作目的都是为了分析，来确定哪些元素要实际移动，下面步骤继续说明。

在序列 $\mathcal{F}$ 中，假设所有前面的元素 $v_1, v_2, \ldots, v_{i-1}$ 的移动操作都已经完成， $f(v_i)$ 表示 $v_i$ 的单步移动操作的增益（割权值的减少）。
所以，为了得出移动 $v_1, v_2, \ldots, v_i$ 的总增益（记作 $\tilde{f}(v_i)$ ），我们需要取和：
\begin{equation}
\tilde{f}(v_i) = \sum\limits_{j=1}^i f(v_j)
\end{equation}
对 $i=1,2, \ldots, 2m$ 分别计算 $\tilde{f}(v_i)$ ，我们形成一个累积和序列
\begin{equation}
\tilde{\mathcal{F}} = \{\tilde{f}(v_1), \tilde{f}(v_2), \cdots,
\tilde{f}(v_{2m})\}
\end{equation}
其中 $\tilde{f}(v_i)$ 是前面讨论过的元素 $v_1$ 到 $v_i$ 移动的总增益。
假设 $\tilde{f}(v_k)$ 是 $\tilde{F}$ 中的最大元素，这意味着移动 $v_1, v_2, \ldots, v_k$ 可以得到最大的增益（即最大减小割权值）。
这样，我们就执行实际的操作，移动 $\{v_1, v_2, \cdots, v_k\}$ 去它对应的另一个子集。
所有上面的程序记为一个移动动作。

尽管移动动作可以重复执行，但是以前在电路分割上的研究已经表明2到4次的移动动作已经足够实现最小化 \cite{Fidducia:DAC'82,Dutt:DAC'96} 。对我们这个情况，实验表明执行一次移动动作已经足够了。

最小割之后，我们将所有剩余功耗分割成块。然后二部图匹配可以在每块内部执行。
因为最小割已经将相关的功耗划到了同一块中，执行二部图匹配之后剩下的未匹配的功耗在其他块中也很难找到匹配了。
所以，不在执行更进一步的二部图匹配了，我们可以由之前的低层和高层的二部图匹配结果直接确定任务迁移操作。
最后没有匹配上的功耗，可以简单的用 DVFS 进行处理。

图~\ref{fig:partitioning} (a)， (b) 和(c) 展示了高层的匹配的一个例子。
在图~\ref{fig:partitioning} (a) 中，低层匹配（图~\ref{fig:cpu_partition} (b) 表示已表示出）之后未匹配上的功耗全部收集形成图 $\mathcal{G}_p$ 。
注意，图 $\mathcal{G}_p$ 中所有的元素都有带权重的边连接，图~\ref{fig:partitioning} 中为简化并没有表示出。
图 $\mathcal{G}_p$ 的初始割由图~\ref{fig:partitioning} (b) 上的虚线表示。然后执行迭代最小割算法，
图~\ref{fig:partitioning} (c) 表示 $\mathcal{G}_p$ 的最终割， $\mathcal{G}_p$ 中的功耗元素被分割成了两个块，
然后，每个新块的形成一个二部图，高层二部图匹配在每个新块执行。


\section{DVFS最终调整}\label{sec:dvfs_adj}

经过前面二部图匹配算法后，留下的还未匹配上的负载功耗引入 DVFS 方法来做最后调整。任务迁移根据低层和高层的二部图匹配结果进行操作，已经匹配上的负载功耗就迁移到了正确的核上，这些就符合 MPC 预测出的功耗分布（在这些位置上功耗可能会有些小的差值）。
迁移操作过后，那些没有匹配上的负载功耗，就被迁移到一个新的位置，因为它们原来的位置可能被匹配的那一个占据了。

假设一个功耗为 $p_i$ 未匹配上的负载被迁移到核 $j$ 上，MPC预测核 $j$ 需要的功耗为 $\bar{p}_j$ 。
$p_i$ 与 $\bar{p}_j$ 并不匹配，它们并不相等。如果 $p_i < \bar{p}_j$ ，表明如果我们保持现在的状态，核 $j$ 的温度将会低于我们设定的顶温度。
因为这个并不影响芯片的可靠性，我们可以保持这个功耗不变。
对另外一种情况 $p_i > \bar{p}_j$ ，我们在该核上执行DVFS操作，
使功耗变化比率为 $r_{dvfs} = \bar{p}_j/p_i$ 。这是在没有超过温度限制的情况下，核 $j$ 可以实现的最大性能。这里也要注意，DVFS 进行的是离散的电压频率调整，所以在实际的应用中， $r_{dvfs}$ 被确定在低于 $\bar{p}_j/p_i$ 的最近水平上。

图~\ref{fig:partitioning} (d)为 $100$ 核微处理器示例的最后调整步骤。
$p_d < \bar{p}_a$ ，所以没有 DVFS， $p_d$ 仅被简单的移动到了新的位置上。
因为 $p_e>\bar{p}_d $ ，所以 DVFS 在 $p_e$ 上有操作。

我们知道在 DVFS 方法中，DC-DC 转换器是用来调整电压水平的，这个会在芯片设计上引入开销。在众核处理器上这是一个严重的问题，尤其是对于每个核都可以进行 DVFS 的情况。
为了减小 DC-DC 转换器实现上的开销，引入 DVFS 块是一种很实用的方法，这个是在空间上相邻的几个核共用一个 DC-DC 转换器。
在这种情况下， DVFS 的决策就要依据对应块上几个核之中的最低电压水平，会影响吞吐量和性能。这个折中是众核架构中一个普遍也很重要的问题，需要在未来的工作上做进一步的研究。

这里总结一下这个新的分层动态温度管理方法，从利用 MPC 确定动态温度管理策略到执行温度管理操作整个流程总结如下。\\
\begin{algorithm}[H]
\caption{分层动态温度管理算法}
\label{alg:whole_flow}
\begin{algorithmic}[1]
  \STATE 用模型预测控制（MPC）方法根据设定的温度限制求期望的功耗分布 $\bar{P}(k)$。
  \STATE 划分相邻核成为低层块。
  \STATE 对每一个块， 用对应的$P(k)$， $\bar{P}(k)$，  和阈值 $e_{th}$建立这个块自己的二部图 $\mathcal{G} =
  (L, R, E)$ 。
   \STATE 在每个低层块上执行二部图匹配，记录匹配对。
   \STATE 收集搜有低层块未匹配上的功耗，建立一个新图 $\mathcal{G}_p = (V_p, E_p)$ ，为最小割做准备。
   \STATE 用改进的迭代最小割方法分割图$\mathcal{G}_p$生成高层块。  \label{step:min_cut}
   \STATE 在第\ref{step:min_cut}生成的每一个块上执行二部图匹配，
   记录匹配对。
   \STATE 根据记录的低层和高层的匹配对确定所有负载的新位置。 
   \STATE 对仍然没有匹配上的负载，按\ref{sec:dvfs_adj}节所述执行DVFS操作。
\end{algorithmic}
\end{algorithm}

\section{本章小结}\label{sec:xiaojie5}
上一章说到用期望功耗与现有功耗构成的任务分配问题，在扩展到众核系统时需要超出可以忍受的计算时间，会使算法失效。
本章主要解决找个问题，解决方法是将众核系统整个芯片上的所有核划分成多块，各自分别计算。这样就能极大降低算法的计算时间。
具体实现是将划分分成两个层次，低层划分按照物理位置划分，高层划分按照功耗元素关系划分。
这样的划分在一定程度上使计算并行化，极大降低计算时间，使算法更加有效。
解决了任务分配问题后，还剩下没有匹配上的任务，由 DVFS 来做最后的处理，保证芯片在安全温度以下。
最后总结了一下新的分层动态温度管理方法的整个流程。














































