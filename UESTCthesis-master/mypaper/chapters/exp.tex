% !Mode:: "TeX:UTF-8"

\chapter{新的动态热管理方法的实现和结果比较}\label{sec:exp}

前面的章节已经介绍了众核处理器动态温度管理方法的基础知识，也详细说明了新提出的动态温度管理方法。
接下来就要实现新的算法，并验证该算法比其他方法更有优势。
 \ref{sec:method_implement} 主要介绍算法实现的详细细节。 
 \ref{sec:result_c} 说明第\ref{chapter:mpc}章描述的未分层的动态温度管理方法的实验结果及比较。
 \ref{sec:result_h} 说明第\ref{chpter:new_method}章描述的分层方法的实验结果及比较。
 %后面三节介绍新的算法与其他动态温度管理方法的优劣， \ref{sec:temp_comp} 介绍瞬态温度上的比较， \ref{sec:time_comp} 介绍算法占用的计算时间开销的比较，
 %\ref{sec:ips_comp} 进行采用不同动态温度管理算法时的处理器性能比较。
\section{新的动态热管理方法的实现}\label{sec:method_implement}
本论文中新的动态温度管理方法的实现是在一个具有两个 8 核 16 线程 CPU 的 linux 服务器上进行的，每个 CPU 主频为 2.90GHZ，服务器内存 64GB。
新的动态热管理方法主要用 MATLAB 实现，主要分为两部分，第一部分为第\ref{chapter:mpc}章描述的未分层方法，和第二部分第\ref{chpter:new_method}章描述的分层方法。
对未分层方法我们构建了四个不同核数量的处理器，从 $16$  核 （$4 \times 4$） 到 $49$  核 （$7 \times 7$）。
针对分层方法我们也构建了四个不同处理器核数量配置的众核处理器，从 $100$ 核（$10 \times 10$）到 $625$ 核（$25 \times 25$）。
这些处理器的热模型由 HotSpot 生成，HotSpot 已经有完整的工具可以直接调用。环境温度设定为 $20^{\circ}$C。
在这个实验中众核处理器由完全一致的Alpha 21264核组成。所有芯片的大小都是 $10mm \times 10mm \times 0.15mm$。
这里我们假设众核处理器中任务运行时相互之间没有通讯也不需要同步。
任务的功耗由 Wattch 通过运行 SPEC 基准程序  \citeup{Henning:IEEEC'00} 生成，初始任务分配为，一个任务随机指定给一个核运行。
接下来的任务分配和调度有动态温度管理方法确定。
我们有 9 个 SPEC 基准程序的实时功耗信息。
对于不同的处理器的功耗信息，我们重复这 9 个功耗信息得到处理器需要的 16 个， 25个实时功耗信息等等。

因为核的大小会随核的数量增长变化，这会超过所谓的“功耗墙”或者“利用率墙”导致不现实的功耗密度  \citeup{Taylor:MICRO'13} ，产生极高的温度。
为解决这个问题，提出了很多解决方法。一个解决方案是灰硅，放缩每个核的功耗  \citeup{Huang:MICRO'11,Taylor:MICRO'13}。另一个更广泛的方法是完全关掉一些核\citeup{Taylor:MICRO'13,Shafique:DAC'14}。
在我们的研究中，我们采用灰硅技术，放缩功耗的大小以保证所有处理器都有相似的功耗密度，这样温度分布就类似于现在的多核芯片。
这个可以通过以一定的比例调整操作频率和电压来实现，放缩比例在表~\ref{tab:param} 中给出。
在我们的这个研究中，我们并不考虑完全关掉一部分核的策略，这会是我们将来的研究方向。
\begin{table}[H]
\centering
\caption{对不同核数处理器在新分层方法的参数}\label{tab:param}{
 \begin{tabular}{|c|c|c|c|}
 \hline
 \hline
 处理器核数 &  放缩比例 & $e_{th}$ & $r$ \\
 \hline 
 \hline
 $16$ 核 ($4 \times 4$) & 1.5 & 1.0 & 20 \\
 \hline
 $25$ 核 ($5 \times 5$) & 0.85 & 0.4 & 50 \\
 \hline
 $36$ 核 ($6 \times 6$) & 0.58 & 0.1 & 50 \\
 \hline
 $49$ 核 ($7 \times 7$) & 0.48 & 0.1 & 50 \\
 \hline
 $100$ 核 ($10 \times 10$) & 0.21 & 0.06 & 500  \\
 \hline
 $256$ 核 ($16 \times 16$) & 0.08 & 0.05 & 2100 \\
 \hline
 $400$ 核 ($20 \times 20$) & 0.052 & 0.04 & 3000 \\
 \hline
 $625$ 核 ($25 \times 25$) & 0.033 & 0.03 & 3000 \\
 \hline
 \hline
 \end{tabular}
 }
 \end{table}
 
对于不同核数的处理器，为保证温度能有效地趋近顶温度，任务迁移过程中的阈值 $e_{th}$ 和 式 \eqref{eq:cost_fun} 中 MPC 调整参数 $r$ 需要手动调整。
这里注意，最优的 $e_{th}$ 和 $r$ 值与微处理器核的数量和结构高度相关，理论上没有必要去计算这些参数在实际的。
在实际的应用中，针对一个确定的众核微处理器，很容易通过实验来调整这些参数。
表~\ref{tab:param} 给出了这些参数的值。我们可以看出 $e_{th}$ 随功耗模型的大小（在我们的情况中也是核的大小）变化。
如果核的大小相对较大， $e_{th}$ 也需要指定一个相对较大的值（即表~\ref{tab:param} 中 16 核的情况）。反之亦然（即表~\ref{tab:param} 中 625 核的情况）。
这是因为较大的功耗有较大的芯片空间供功耗分布，所以对相同的温度容忍限制，允许有更大的功耗差值。
另一个现象是核数越大，需要较大的 $r$ 值。
这是因为在式 \eqref{eq:cost_fun} 中，当核数增长的时候 $Y_{ceil}-Y_k$ 中的每个元素并没有变化太大，
但是 $\Delta P_k$ 中的每个元素会变得小很多（因为每个核的功耗缩小）。
为了使 $\Delta P_k$ 有更小的解， $r$ 的值需要变大。
这里注意625核的情况 $r$ 值仍然是 $3000$，与 $400$ 核的情况相同，因为我们发现到这个程度再继续增大 $r$ 值没有明显的影响。

对于分层方法，在低层划分上我们划分每 $25$ ($5 \times 5$) 个相邻核为一块。
在高层处理中，如果图 $\mathcal{G}_p$ 中的元素数目超过 $240$ 就用改进迭代最小割算法进行分割。

为了最小化任务迁移的开销，任务迁移和 DVFS 的启动周期设定为 $20$s。任务迁移的开销来自于计算核迁移操作。
通常处理器核数较小时，用较小的迁移周期。因为核数少时，计算开销和迁移操作开销（关系到核与核之间的通信）都很小。
对中核处理器情况，因为核数很大，频繁的任务迁移是很难执行的，所以迁移周期延长。迁移间隔内一个核的负载可能会增长很多，这样可能引起超出温度限制。
在这种情况下，我们在迁移间隔内需要保证安全的时候只能执行 DVFS。

在实验中，除了任务迁移决策计算的开销，任务迁移操作的开销也要考虑进去。
正常的任务迁移操纵开销大概是 $10^6$ 个时钟周期，对 $1$ GHZ的处理器大概是 $1$ms~\citeup{Cuesta:ISVLSI'10}。
因为在众核处理器中核数很大，核之间通信时间很长，这样的开销会很大。
所以我们设定上百核处理器的任务迁移时间为 $100$ms。
在实验中我们要考虑任务迁移的功耗。这个功耗由迁移时间内核的通信产生，在迁移时对应的两个核不处理任何任务。
所以我们假设任务迁移时间的功耗小于任务处理时间的功耗。为保证安全，我们将任务迁移时的功耗设定为之前处理任务时的平均功耗，用这样的功耗提供给MPC做预测。

\begin{pics}{不同DTM方法下的16核CPU瞬态温度}{fig:temp_c}
   \addsubpic{不采用任何DTM方法}{width=0.4\columnwidth}{fig/16tbef}
   \addsubpic{采用未分层DTM方法}{width=0.4\columnwidth}{fig/16taft}
   \addsubpic{采用\cite{Zanini:ECCTD'09}中的DTM方法 }{width=0.4\columnwidth}{fig/16tdvfs}
 \end{pics}
 
作为未分层方法的比较，我们实现了另外一种基于MPC结合DVFS的方法~\cite{Zanini:ECCTD'09}。
针对分层方法，我们既将其与未分层方法比较也与方法~\cite{Zanini:ECCTD'09}进行比较，
还选择了\cite{Hanumaiah:TCAD'11}中的动态温度管理方法作为对比，它和我们的研究有相同的目标，即改性能处理器有温度限制时最大化性能（吞吐量）。
我们在实验中实现了 \cite{Hanumaiah:TCAD'11} 的作者提供的开源项目 MAGMA V2。MAGMA只能给出100核处理器的结果，对于更大的核数情况会有“超出内存”错误。
在这里所有的方法都用相同的激活周期，功耗信息和顶温度。
\section{未分层方法与其他方法的结果比较}\label{sec:result_c}
  

 \begin{pics}{不同DTM方法下的16核CPU核间瞬态温度方差}{fig:var_c}
   \addsubpic{不采用任何DTM方法}{width=0.4\columnwidth}{fig/16vbef}
   \addsubpic{采用未分层DTM方法}{width=0.4\columnwidth}{fig/16vaft}
   \addsubpic{采用\cite{Zanini:ECCTD'09}中的DTM方法 }{width=0.4\columnwidth}{fig/16vdvfs}
 \end{pics}
 首先我们实现16核处理器不采用温度管理时的瞬态温度测量,如图~\ref{fig:temp_c} (a)。
 核的温度大概在 $90^{\circ}$C 到 $120^{\circ}$C。温度在 $120^{\circ}$C 左右会影响芯片的可靠性。其核之间温度的方差，如图~\ref{fig:var_c} (a)。
 可以看出核之间温度方差很大。
 
 接下来我们测试未分层方法，将安全顶温度设置为 $105^{\circ}$C。
 温度管理在第200秒时被激活，激活周期为 $1$s。采用未分层方法后的瞬态温度如图~\ref{fig:temp_c} (b)。
 可以看出温度管理激活后所有核的温度都趋近于给定的 $105^{\circ}$C 顶温度。我们可以注意到这里有一些尖峰超过顶温度，
 这些尖峰由 温度管理周期内的快速改变的温度响应引起，所以这个不能避免，所有的温度管理方法都会出现这个问题。
 为了保证芯片的安全性，我们设置顶温度比实际安全温度稍微小一点。
 为方便分析我们也计算了核之间的温度方差如图~\ref{fig:var_c} (b) 所示，显然采用未分层方法后，核之间温度方差被极大降低了。
 
 然后我们实现\cite{Zanini:ECCTD'09}中的动态温度管理方法。同样的，我们在第200秒时激活这个温度管理方法，为每个核设置同样的顶温度 $105^{\circ}$C。
 16核处理器对应的瞬态温度如图~\ref{fig:temp_c} (c)，对应的核间温度方差如图\ref{fig:var_c} (c)。
 从图~\ref{fig:temp_c} (c) 可以看出，这个动态温度管理方法实际上非常有效，能够有效保证温度在顶温度以下（尖峰除外）。
 但是，通过比较 图~\ref{fig:temp_c} (c) 和 图~\ref{fig:temp_c} (b)，
 \cite{Zanini:ECCTD'09}中的动态温度管理算法很明显导致了一个较大的核间温度方差，我们的新方法在这方面要好得多。
 这是因为 \cite{Zanini:ECCTD'09} 只用了DVFS，有些核的温度不调整电压和频率也本来就在顶温度以下。
 在这种情况下，\cite{Zanini:ECCTD'09} 对这些核没有采取任何措施，所以导致一些核的温度在顶温度以下。这个表示，处理器没有在最高性能运行。

  \begin{table*}
%\tabcolsep=1pt
 \centering
 \caption{未分层方法与其他方法的核间温度方差比较}~\label{tab:var_c} 
 \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
 \hline
 \hline
                &         & \multicolumn{2}{c|}{周期 $1$s} & \multicolumn{2}{c|}{周期 $10$s}& \multicolumn{2}{c|}{周期 $20$s} & \multicolumn{2}{c|}{周期 $40$s}\\
 核数  & $var_o$ & $var_d$ &$var_n$ & $var_d$ &$var_n$  & $var_d$ &$var_n$ & $var_d$ &$var_n$\\
 \hline 
 \hline
 $16$ 核 & 60.6 & 27.0 & 9.2  & 25.5 & 11.1 & 25.5 & 11.5 & 25.3 & 13.2\\
 \hline
 $25$ 核 & 79.0 & 29.8 & 15.5 & 31.2 & 12.5 & 31.1 & 12.8 & 30.9 & 16.1\\
 \hline
 $36$ 核 & 66.0 & 27.7 & 11.4 & 26.8 & 11.5 & 25.5 & 12.9 & 25.6 & 12.8\\
 \hline
 $49$ 核 & 60.4 & 25.7 & 6.4  & 23.1 & 6.7  & 22.9 & 6.8  & 23.2 & 7.8 \\
 \hline
 \hline
 \end{tabular}
 \end{table*}
 
 我们已经展示了两种动态温度管理方法在16核处理器上的详细性能比较。我们也在不同处理器核数不同激活周期也比较了两种方法。
 不同激活周期的核间温度方差的比较结果记录在表~\ref{tab:var_c}。
 其中 $var_o$ 表示不采用动态温度管理状态下的平均方差，
 $var_d$ 表示 \cite{Zanini:ECCTD'09}中的动态温度管理方法下的平均核间瞬态温度方差，
 $var_n$ 表示 我们的未分层方法下的平均核间瞬态温度方差。
 从这个表中我们可以看出两种动态温度管理方法都很大程度上降低了核间温度方差，也就是平衡和芯片温度。
 我们的未分层方法要明显比 \cite{Zanini:ECCTD'09} 中的方法好很多。
 更小的温度方差能够使芯片可靠性更好。
 激活周期延长方差也仅仅稍微增大一点。
 激活周期 40s  时，我们新方法的方差仍然明显小于方法 \cite{Zanini:ECCTD'09}。
 后面将会介绍，大的激活周期可以使计算开销更小。
 
 
 
 
 \begin{table*}
\tabcolsep=1pt
\small
 \centering
 \caption{未分层方法与其他方法的IPS比较 }~\label{tab:ips_c} 
 \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
 \hline
 \hline
                &         & \multicolumn{2}{c|}{周期 $1$s} & \multicolumn{2}{c|}{周期 $10$s}& \multicolumn{2}{c|}{周期 $20$s}& \multicolumn{2}{c|}{周期 $40$s}\\
 核数  &$MIPS_o$ & $MIPS_d$ & $MIPS_n$  & $MIPS_d$ & $MIPS_n$  & $MIPS_d$ & $MIPS_n$  & $MIPS_d$ & $MIPS_n$ \\
 \hline 
 \hline
 $16$ 核 & 651.5 & 630.6 & 643.8  & 628.9 & 642.1  & 628.8 & 642.2 & 628.4 & 641.8  \\
 \hline
 $25$ 核 & 530.2 & 508.0 & 520.4 & 508.9 & 519.7  & 508.6 & 519.2  & 508.2 & 518.8  \\
 \hline
 $36$ 核 & 477.1 & 460.4 & 471.4  & 459.6 & 470.9  & 458.1 & 470.5  & 457.5 & 470.4  \\
 \hline
 $49$ 核 & 442.6 & 426.4 & 439.1  & 423.8 & 438.0  & 423.3 & 438.1  & 422.7 & 437.5  \\
 \hline
 \hline
 \end{tabular}
 \end{table*}
 
 除了可靠性方面的考虑，处理器的计算性能也是同等重要的。我们也比较了采用这两种方法的是处理器的性能。
 处理器性能可以由它的吞吐量来表示，就是单位时间任务的完成量。
 在这个实验中，我们通过测量核的平均每秒指令数（IPS）代表吞吐量来估计处理器性能。
 也就是更高的 IPS 表示有更高的性能。
 新的未分层方法和\cite{Zanini:ECCTD'09}中方法的每核平均IPS 记录在表~\ref{tab:ips_c} 中。
 $MIPS_o$ 代表不采用动态温度管理时的核平均每秒百万指令数（MIPS），
 $MIPS_d$ 表示 \cite{Zanini:ECCTD'09}中方法的核平均 MIPS，
 $MIPS_n$ 表示我们新的未分层方法的核平均 MIPS。
 %我们新的未分层方法比 \cite{Zanini:ECCTD'09} 中方法的性能提升也以 $(MIPS_n - MIPS_d)/MIPS_d$进行计算。
 可以看出，我们的新方法比 \cite{Zanini:ECCTD'09} 中的方法有很大提升。对理想状态性能$MIPS_o$显著减少。
 
   \begin{table*}
\tabcolsep=1pt
\small
 \centering
 \caption{未分层方法与其他方法的计算时间比较}~\label{tab:time_c} 
 \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
 \hline
 \hline
	        & \multicolumn{2}{c|}{周期$1$s} & \multicolumn{2}{c|}{周期$10$s} & \multicolumn{2}{c|}{周期$20$s} & \multicolumn{2}{c|}{周期$40$s}\\
核数	& $t_p$($10^{-3}$s) &$t_m$($10^{-3}$s) &$t_p$($10^{-3}$s) &$t_m$($10^{-3}$s) & $t_p$($10^{-3}$s)  & $t_m$($10^{-3}$s) & $t_p$($10^{-3}$s)  & $t_m$($10^{-3}$s)\\
 \hline 
 \hline
 $16$ 核 & 0.29 & 4 & 0.031 & 0.3 & 0.019 & 0.1 & 0.010 & 0.10 \\
 \hline
 $25$ 核 & 0.38 & 8 & 0.053 & 0.7 & 0.035 & 0.3 & 0.022 & 0.16 \\
 \hline
 $36$ 核 & 0.50 & 19 & 0.063 & 1.7 & 0.044 & 0.9 & 0.032 & 0.43 \\
 \hline
 $49$ 核 & 0.61 & 41 & 0.078 & 4.1 & 0.059 & 1.9 & 0.041 & 0.83 \\
 \hline
 \hline
 \end{tabular}
 \end{table*}
 
 最后我们来比较，测量了我们新方法在不同激活周期下的计算时间。
 %运行时间被标准化为微处理器每秒的动态温度管理计算时间。
 由于未分层方法主要由 MPC计算和二部图匹配组成，我们将算法计算时间分成 MPC时间（$t_p$）和匹配时间（$t_m$）。
 这个时间记录在表 \ref{tab:time_c} 中。
 可以看出，MPC和匹配的计算时间随核数的增长而增加。MPC的计算时间比匹配要小很多。
 对激活周期是1s的情况，49核微处理器需要的匹配计算时间为0.04s，
 这个被看做一个比较大的延迟，但是考虑到这是49核中的一个核的计算，整体的吞吐量损耗又可以忽略。
 如果增加激活周期，计算时间将会减少，伴随着一点可靠性的损失。
 即其温度方差会增加（比对表~\ref{tab:var_c} 和表~\ref{tab:ips_c}）。
 \cite{Zanini:ECCTD'09}中的方法，执行时间只有MPC时间（$t_p$）。
 我们的新方法虽然计算时间比~\cite{Zanini:ECCTD'09} 要稍微多一点，但是整体来说，在性能和可靠性上还是有很大提升的。
 
 总体来说，未分层方法比较适合于核数不是太多的多核微处理器，对于核数超过100的众核处理器超出了未分层方法的能力。
 因为匹配算法复杂度较高，随核数增加计算时间会显著增加。在核数较少时并不明显，当处理器核数超过100时将会显著增加，后面会做介绍。
 下面的分层方法主要来进行众核方面的比较。
 
 
 


 

\section{分层方法与其他方法的结果比较}\label{sec:result_h}

\begin{pics}{不同DTM方法下的100核CPU瞬态温度}{fig:temp}
   \addsubpic{不采用任何DTM方法}{width=0.4\columnwidth}{fig/T_bef}
   \addsubpic{采用分层DTM方法}{width=0.4\columnwidth}{fig/T_aft}
   \addsubpic{采用未分层方法}{width=0.4\columnwidth}{fig/T_cer}
   \addsubpic{采用\cite{Zanini:ECCTD'09}中的DTM方法 }{width=0.4\columnwidth}{fig/T_dvfs}
 \end{pics}
 
%\section{与其他方法的瞬态比较}\label{sec:temp_comp}
首先我们不进行任何温度管理让100核处理器在最大速度上运行。图~\ref{fig:temp} (a)就是这个处理器的瞬态温度。我们可以看出，核的温度大概是从 $90^{\circ}$C
到 $120^{\circ}$C。我们也测量了温度的方差，见图~\ref{fig:var_comp} (a)。可以看出，没有任何温度管理的情况下，核之间的温度差也很大。


接下来我们把顶温度设定在 $105^{\circ}$C，测试新的分层动态温度管理方法在100核处理器上的效果。
分层动态温度管理方法在第200秒时被激活，激活周期为 $20$s。对应的瞬态温度就是图~\ref{fig:temp} (b)，对应的温度方差就是图~\ref{fig:var_comp} (b)。
分层动态温度管理方法被激活之后，所有核的温度开始趋近于设定的顶温度 $105^{\circ}$C，核之间的温度差也减小了很多。

\begin{pics}[H]{不同DTM方法下的100核CPU核间瞬态温度方差}{fig:var_comp}
   \addsubpic{不采用任何DTM方法}{width=0.4\columnwidth}{fig/var_bef}
   \addsubpic{采用分层DTM方法}{width=0.4\columnwidth}{fig/var_aft}
   \addsubpic{采用未分层方法}{width=0.4\columnwidth}{fig/var_cer}
   \addsubpic{采用\cite{Zanini:ECCTD'09}中的DTM方法 }{width=0.4\columnwidth}{fig/var_dvfs}
 \end{pics}
 
作为对比， 我们的未分层方法和 \cite{Zanini:ECCTD'09} 中基于 MPC 结合 DVFS 的方法也进行了测试。
顶温度同样被设定为 $105^{\circ}$C，所有的方法仍然在相同的时间点被激活，即第 200 秒，激活周期仍然是 $20$s。
图~\ref{fig:temp} (c) (d) 和 图~\ref{fig:var_comp} (c) (d) 就是这两种方法对应的瞬态温度，和核之间温度方差。
新的分层动态热管理方法和 未分层方法有相似的瞬态温度，比 未分层方法的核之间温度方差稍微大一点点，
说明新方法并不能最优地平衡整个芯片的温度（后面会介绍，新分层方法在开销和扩展性上比 未分层方法要好得多）。
\cite{Zanini:ECCTD'09} 中的动态温度管理方法在瞬态温度和核之间温度差上要比前两种方法差很多。


下面我们对比 \cite{Hanumaiah:TCAD'11} 中的方法。这个方法也是执行 DVFS 和任务迁移，来使核的温度趋近于顶温度。
不过，这个方法为了减小计算开销，在做动态温度管理决策的时候假设每个核都核其他核热隔离。这种假设在核数较少的多核芯片上或许可以，因为核数较少时，核之间有大面积的缓存区域阻隔了核间热交换。
但是在众核情况下，因为每个核面积较小，热交换很明显，并且不能被忽略。
该方法的 100 核处理器温度即图~\ref{fig:magma} (a) 所示。因为这里的仿真步长较大，所以温度波形是直的线段。
依据这样的温度来做动态温度管理决策，温度大部分时间都是趋近顶温度的。
但是因为核与核之间的零热交换，所以这样的温度并不是实际的温度。
我们修改了MAGMA 程序，画出了考虑核间热交换的实际温度，如图~\ref{fig:magma} (b) 所示。
我们很清楚地看到这个方法的动态温度管理决策不是最优的，会明显的超出实际温度的限制。
核与核之间的热交换对众核处理器的温度具有极大的影响，导致严重超出 $105^{\circ}$C 的顶温度。
从图~\ref{fig:magma} 我们可以看出，温度控制有一个延时调整问题。
这是因为在 \cite{Hanumaiah:TCAD'11} 的方法中，当当前温度并不完全等于顶温度的时候，核或者被关掉（如果当前温度高于顶温度），或者全速运行（如果当前温度低于顶温度）。
但是在图~\ref{fig:temp} 中，所有基于 MPC 的动态温度管理方法都没有这个问题，因为它们可以提前预测来做决策，这样就会是比较平滑的温度控制。
\begin{pics}[H]{100核CPU执行\cite{Hanumaiah:TCAD'11}中的DTM方法的瞬态温度}{fig:magma}
   \addsubpic{假设核间没有热交换的瞬态温度}{width=0.8\columnwidth}{fig/magma_100_max}
   \addsubpic{有核间热交换的真实瞬态温度}{width=0.8\columnwidth}{fig/comp_magma_100}
 \end{pics}

 
表~\ref{tab:var} 记录了不同核数的处理器的核之间温度方差。表中 $var_o$ 是没用任何动态温度管理方法时核之间温度方差，
$var_d$ 是 \cite{Zanini:ECCTD'09} 中动态温度管理方法的核之间温度方差，
$var_n$ 是 未分层方法的核之间温度方差，
$var_h$ 是新的分层动态温度管理方法的核之间温度方差，
$var_g$ 是 \cite{Hanumaiah:TCAD'11} 中动态温度管理方法的核之间温度方差。
不同核数的结果类似， 未分层方法稍微优于我们新的分层动态温度管理方法，基于 MPC 只结合 DVFS 的方法明显有较大的核间温度方差。
\cite{Hanumaiah:TCAD'11} 中的方法只完成了 $100$ 核的实验，其核之间温度方差与未分层方法接近。

\begin{table}[H]
\centering
 \caption{分层方法与其他方法核间温度方差比较 \label{tab:var}}{
 \begin{tabular}{|c|c|c|c|c|c|}
 \hline
 \hline
 %%Distribution  & $var_o$ & $var_d$ &$var_n$ & $P_d$ & $P_n$ \\
 核数  & $var_o$ & $var_d$ & $var_n$ & $var_h$ & $var_g$ \\
 \hline 
 \hline
 $100$ 核 ($10 \times 10$) & 54.2 & 18.8 & 5.5 & 7.6 & 5.9\\

 \hline
 $256$ 核 ($16 \times 16$) & 50.8 & 19.3 & 3.4 & 6.5 & N/A\\
 \hline
 $400$ 核 ($20 \times 20$) & 52.1 & 16.7 & 2.5 & 4.1 & N/A\\
 \hline
 $625$ 核 ($25 \times 25$) & 50.5 & 15.9 & 2.3 & 4.1 & N/A\\
 \hline
 \hline
 \end{tabular}}
 \end{table}
 
 %\section{与其他方法的算法执行时间比较}\label{sec:time_comp}
  \begin{table}
   \tabcolsep=2pt
    \caption{分层方法与其他方法的平均计算时间比较\label{tab:time}}{
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
   	        & \multicolumn{4}{c|}{分层方法} & \multicolumn{3}{c|}{未分层方法} & \multicolumn{2}{c|}{\cite{Zanini:ECCTD'09}}& \multicolumn{2}{c|}{\cite{Hanumaiah:TCAD'11}} \\
    \hline
   核数	& $t_p$ & $t_m$ &$t_a$ &
   $t_{all}$ & $t_p$ & $t_m$ &$t_{all}$  &
   $t_p$ &$t_{all}$ & $t_{m}$ &$t_{all}$\\
                                  &   $(10^{-4}s)$ & $(10^{-4}s)$ &
                                  $(10^{-4}s)$ & $(10^{-4}s)$ & $(10^{-4}s)$
                                  &   $(s)$  & $(s)$  & $(10^{-4}s)$ & $(10^{-4}s)$ &   $(s)$  & $(s)$\\
    \hline 
    \hline
   $100$ & 1.58 & 1.63  & 0     & 3.21 & 1.49 & 0.01 & 0.01 & 1.60 & 1.60 & 0.01 & 0.01\\
    \hline
   $256$ & 2.85 & 19.26 & 1.58  & 23.7 & 2.93 & 0.45 & 0.45 & 2.80 & 2.80 & 0.09 & 0.09\\
    \hline
   $400$ & 4.88 & 7.77  & 3.27  & 15.9 & 5.38 & 1.90 & 1.90 & 5.29 & 5.29 & 0.34 & 0.34\\
    \hline
   $625$ & 9.09 & 12.27 & 17.49 & 38.8 & 8.27 & 8.63 & 8.63 & 8.87 & 8.87 & 0.99 & 0.99\\
    \hline
    \hline
    \end{tabular}}
    \end{table}
	
 从前面的比较可以看出，我们新提出的分层动态温度管理方法与 未分层方法在瞬态温度和核之间温度方差上的相差不大。
 在众核处理器上与 未分层方法、 \cite{Hanumaiah:TCAD'11}相比，我们的新方法真正的亮点是可扩展性和小开销。
 我们测定这几种算法的平均每秒执行时间。
 我们的新方法主要由 MPC，二部图匹配（任务迁移），最小割划分组成。为更好分析，我们将算法的总执行时间分为 MPC 时间 $t_p$ ，匹配时间 $t_m$，最小割划分时间 $t_a$。
 匹配操作的执行时间一部分为低层匹配时间，另一部分为高层匹配时间。对于低层匹配时间，如果这里有多个匹配操作在并行执行，我们只计最长的一个，这个时间才是主导延时的时间。
 未分层方法也有 MPC 时间 $t_p$ 和匹配时间 $t_m$ ，但是没有最小割划分时间 $t_a$ 。
\cite{Zanini:ECCTD'09} 中的方法只有 MPC 时间 $t_p$。
 尽管 \cite{Hanumaiah:TCAD'11} 中的方法只完成了100核的情况，但是我们还是可以测试它的任务迁移时间 $t_m$ 。我们可以用正确维度的随机矩阵输入给对应的函数。
 表~\ref{tab:time} 记录了各算法在不同核数处理器上的执行时间。很显然随核数增长， 未分层方法开销明显上升。
 从 400 核的情况开始，每秒的平均管理决策时间要超过1s，这是完全不能接受的。
 \cite{Hanumaiah:TCAD'11} 中的方法在任务迁移计算上的时间也随核数很快增长，使它不能扩展到众核应用中。
 根据这篇论文，我们找出任务迁移算法的时间复杂度为 $O(nq)^3$（跟未分层方法的任务迁移算法接近），其中$n$是核数，$q$是任务数量。
 这篇论文中假设 $n=q$ ，那么当核数增长额时候， $O(n^6)$ 的复杂度使任务迁移占用了太多的时间。
 相对地，我们新的分层算法的计算时间增长缓慢。即使是625核的情况（这已经是很大的核数了），我们的方法平均每秒消耗 4 ms 做管理决策。
 这仅仅是 $0.4\%$ 的计算时间花费在少数几个核上，因此这个可以被忽略。
 当然，\cite{Zanini:ECCTD'09} 中的方法需要最少的时间计算开销，但是我们的新方法只在任务迁移上花费很少的开销就使性能显著提成，下面将继续介绍。

   

\begin{table}
\centering
 \caption{分层方法与其他方法的每核平均IPS比较 \label{tab:ips}}{
 \begin{tabular}{|c|c|c|c|}
 \hline
 \hline
 核数  &$MIPS_o$ & $MIPS_d$  & $MIPS_h$ \\%&  \textcolor{red}{$MIPS_h$} \\
 \hline 
 \hline
 $100$ 核 ($10 \times 10$) & 290.8 & 279.6 & 281.5 \\%& \textcolor{red}{231.9}\\
 \hline
 $256$ 核 ($16 \times 16$) & 210.2 & 202.9 & 207.1 \\%& \\
 \hline
 $400$ 核 ($20 \times 20$) & 182.1 & 174.7 & 178.8 \\%& \\
 \hline
 $625$ 核 ($25 \times 25$) & 156.5 & 150.2 & 154.4 \\%& \\
 \hline
 \hline
 \end{tabular}}
 \end{table}
 
 %\section{与其他方法的性能比较}\label{sec:ips_comp}
 
 最后我们测定不同众核处理器采用各种动态温度管理方法的性能。
 每秒执行的指令数（IPS）是衡量处理器性能一个标准。
 因为未分层方法和 \cite{Hanumaiah:TCAD'11} 中的方法有很大的开销，不能完成众核处理器的管理决策，
 所以在性能对比中并没有考虑这两个方法。
 表~\ref{tab:ips} 记录了采用新分层方法和仅采用DVFS的方法时的平均 IPS。
 在表中 ， $MIPS_o$ 表示不采用任何动态温度管理方法时单个处理器核的平均IPS（以百万计就是MIPS），
 $MIPS_d$ 表示采用 \cite{Zanini:ECCTD'09} 中方法时单个处理器核的平均IPS，
 $MIPS_h$ 表示采用我们的新分层方法时单个处理器核的平均IPS。
 $MIPS_o$ 是理想性能，是在处理器没有任何温度限制的情况下取得的。
  $MIPS_h$ 只比  $MIPS_o$ 小一点，说明在确定管理决策时，我们新的分层算法是很有效的。
  从表中可以看出，新的分层算法在性能上优于 \cite{Zanini:ECCTD'09} 中的算法。
  尽管新算法有稍微大一点的开销，但是消耗在任务迁移决策的时间减少了 DVFS 激活的次数，带来的是性能收益。
  我们注意到，新方法相比于 \cite{Zanini:ECCTD'09} 中的方法在吞吐量上的提升和运行的应用有很大关系。
  比如，如果这里有很低温度的核（甚至是闲置无任务的核），新方法就会比 \cite{Zanini:ECCTD'09} 中方法有更明显的吞吐量提升，
  因为低温核可以被任务迁移充分利用，减少DVFS操作。
  
 \section{本章小结}\label{sec:xiaojie6}
 
 本章实现了新提出了未分层和分层动态温度管理方法，并且实现了与其他方法来做比较。
 通过比较，未分层方法能最优地平衡芯片温度，提升处理器性能，在核数较少的多核芯片上有很大优势，但是在扩展性上并不如分层方法。
 虽然在瞬态温度方差上新的分层方法并不是最好的结果，
 并不能最优地平衡芯片温度，但是也与未分层方法相差不大。
 在众核系统中新的分层方法与未分层方法、 \cite{Hanumaiah:TCAD'11}相比是在可扩展性和小开销上具有巨大的优势。
 在计算开销上新的分层算法要比 \cite{Zanini:ECCTD'09} 中的差，但是新的方法提升了处理器性能。所以总体来说，新的动态温度管理方法比其他方法有很大优势。
 
 
 
 


























